### next-form
> 基于next组件库的表单操作

## 使用field获取最终的数据
> 使用spliceArray实现删除操作，最后获取到的值是一个平铺的数据。

```
{
    title.0 : 0,
    content.0: 0,
    title.1 : 1,
    content.1: 1,
}
```
## 使用field的parseName属性获取结构化数据
> 使用getValues才可以获取到结构化数据

- 当从最后位置删除表单区块时，获取到的结构化数据的数组长度不会减少，从非最后位置删除时正常。
```
{
  title: [0, 1],
  content: [0, 1],
}
```
- 两层的嵌套之后获取到的数据
> 获取到的数据并不理想

```
// 外层两个
{
  title: [0, 1],
  content: [0, 1],
  name: {
    0-0: '0-0',
    1-0: '1-0',
  },
  age: {
    0-0: '0-0',
    1-0: '1-0',
  },
}
// 内层两个
{
  title: [0],
  content: [0],
  name: {
    0-0: '0-0',
    0-1: '0-1',
  },
  age: {
    0-0: '0-0',
    0-1: '0-1',
  },
}
```
## 受控形式
- 不用过多的考虑field删除时移位的问题
- 深层次形式的嵌套表单代码逻辑简单，而且最后获取到的数据结构更加清晰合理
```
[
  {
      title: 0,
      content: 0,
      children: [
        {
          name: '0-0',
          age: '0-0',
        },
        {
          name: '0-1',
          age: '0-1',
        }
      ]
  },
  {
      title: 1,
      content: 1,
      children: [
        {
          name: '1-0',
          age: '1-0',
        }
      ],
  }
]
```
> 在表单只有一层的时候使用field以及受控形式相差不大，当表单的有多层嵌套的时候或者表单区块之间的表单项不同的时候建议使用受控形式，逻辑简单清晰，不易出错。


